# A dynamic list of GfG problems-interview rounds :neckbeard:

# Plan: #
* 1st Iteration(15- 29 July)
    - Enlisting
* 2nd Iteration(1-15 Aug)
    - likh-likh ke(each) & !lite_this_time
* 3rd Iteration(16-30 Aug)
    - code each
* do from GfG itself
    - update list & outsider view

## TODO's :
    - [ ] Write complexities in front of each line
    - [ ] Directi's coding questions 
    - [ ]
    - [ ] Keep updating list(the list is not even 50% of GfG)


## Notes: 
```diff
-only valid when #Interviewer_gets_em#
- Respect every Question & they will respect you
+stack of implementaion helps heaps in recursion(GfG BIT videos)
-Directi == DP( do as much as can)
+ itna ki, koi sote mei utha ke puche toh bhi(cz that's gonna happen YOU KNOW THAT)
```


<details>
    <summary>Data Structures</summary>
    <details>
        <summary>BST</summary>
            <details>
                <summary>1.Intro</summary>
                    1.1 Declare<br>
                    1.2 Insert<br>
                    1.3.1 Delete a node<br>
                    1.3.2 Delete a tree<br>
                    1.4 search(key 'x')
                    1.5.1 Array to BST<br>
                    1.5.2 BST to array<br>
            </details> 
            <details>
                <summary>2.Traversal</summary>
                    2.1.1 DFS-recursion<br>
                    2.1.2 DFS-1 stack<br>
                    2.1.3 DFS-2 stack<br>
                    2.1.4 DFS-Morris Traversal<br>
                    2.2 BFS<br>
                    2.3 Line By Line BFS<br>
                    2.4 Diagonal BFS<br>
                    2.5 Spiral BFS<br>
                    2.6 Rerse BFS<br>
            </details>     
            <details>
                <summary>3.Const & Conv</summary>
                    3.1 Construct a tree from:<br>
                        3.1.1 preO & postO<br>
                        3.1.2 inO & preO<br>
                        3.1.3 preO & postO of Mirror Tree<br>
                        3.1.4 Linked List Rep<br>
                    3.2 Convert a BST to:<br>
                        3.2.1 Double Linked list(all 4 sets)<br>
                        3.2.2 Sum Tree<br>
                    3.3 Flip the tree<br>
                    3.4 Min swaps to convert BT to BST<br>
            </details> 
            <details>
                <summary>4.Check & Print</summary>
                    4.1 Check:<br>
                        4.1.1 isMirror?<br>
                        4.1.2 isFoldale?<br>
                        4.1.3 isSumTree?<br>
                        4.1.4 has children sum property?<br>
                        4.1.5 cousins?<br>
                        4.1.6 all leaves at same level?<br>
                        4.1.7 if preO, postO, inO are of same tree?<br>
                        4.1.8 prefect tree?<br>
                        4.1.9 full BT?<br>
                        4.1.10 complete tree?<br>
                        4.1.11 is height balanced/Red-Black tree?<br>
                        4.1.12 is subset of another BST?<br>
                        4.1.13 are Mirror?<br>
                        4.1.14 are Identical?<br>
                    4.2 Print:<br>
                        4.2.1 cousins of each node<br>
                        4.2.2.1 print all root to leaf paths- recursion<br>
                        4.2.2.2 print all root to leaf paths- w/orecursion<br>
                        4.2.3 nodes at odd levels<br>
            </details>      
            <details>
                <summary>5.Summation</summary>
                    5.1 sum of all nodes<br>
                    5.2 sum of all parent nodes having child node x<br>
                    5.3 sum of all leaf nodes<br>
                    5.4 diagonal sum<br>
                    5.5 is there a leaf such that, sum(root->leaf) == root<br>
                    5.6 sum of nodes on longest path <br>
                    5.7 max sum such that no 2 nodes are adjacent<br>
                    5.8 find largest sum<br>
                    5.9 print all k-sum paths<br>
                    5.10 sum(root-> leaf) k<br>
            </details>     
            <details>
                <summary>6.LCA</summary>
                    6.1 LCA(all 3 sets)<br>
                    6.2 find dist b/w 2 nodes<br>
                    6.3 print ancestor of a node<br>
                    6.4 print k-th ancestor<br>
            </details> 
            <details>
                <summary>7.Misc</summary>
                    7.1 succinct encoding of BST<br>
                    7.2 custom tree<br>
                    7.3 tree isomorphism <br>
                    7.4 ways to color differently<br>
                    7.5 size of tree<br>
                    7.6 height/ depth of tree<br>
                    7.7 find deepest node<br>
                    7.8 max widht<br>
                    7.9 min depth<br>
                    7.10 vertical widht<br>
                    7.11 bottom view<br>
                    7.12 const leaf nodes<br>
                    7.13 connect nodes at same level(all 4)<br>
                    7.14 level with max no of nodes<br>
                    7.15 swap nodes at level k<br>
                    7.16 tilt of BST<br>
                    7.16 number of iterations to pass infor into all nodes<br>
            </details>                        
    </details>
    <details>
        <summary>Special Trees</summary>
        <details>
            <summary>1.Segment Tree</summary>
            <details>
                <summary>1.1 Const</summary>
            </details>   
            <details>
                <summary>1.2 getSum</summary>
            </details>   
            <details>
                <summary>1.3 Update</summary>
            </details>   
            <details>
                <summary>1.4 RMQ</summary>
            </details>   
            <details>
                <summary>1.5 Lazy Prop</summary>
            </details>                                                                  
        </details>  
        <details>
            <summary>2.Trie </summary>
            <details>
                    <summary>2.1 Const</summary>
            </details>  
            <details>
                    <summary>2.2 Insert</summary>
            </details>                
             <details>
                    <summary>2.3 Search</summary>
            </details>          
            <details>
                    <summary>2.4 Delete</summary>
            </details> 
             <details>
                    <summary>2.5 Longest Prefix</summary>
            </details>          
            <details>
                    <summary>2.6 Unque rows in boolean matrix</summary>
            </details>                                             
        </details>  
        <details>
            <summary>3.Balanced BT</summary>
            <details>
                <summary>3.1 AVL/BIT</summary>
                <details>
                        <summary>3.1.1 Declare </summary>
                </details>                      
                <details>
                        <summary>3.1.2 Insertion </summary>
                </details>          
                <details>
                        <summary>3.1.3 Deletion </summary>
                </details>                   
            </details>   
            <details>
                <summary>3.2 Red-Black Tree</summary>
                <details>
                        <summary>3.2.1 Declare </summary>
                </details>                      
                <details>
                        <summary>3.2.2 Insertion </summary>
                </details>          
                <details>
                        <summary>3.2.3 Deletion </summary>
                </details>                      
            </details>                    
        </details> 
        <details>
            <summary>4.Heap</summary>
        </details>  
        <details>
            <summary>5.Splay Tree</summary>
                <details>
                        <summary>5.1.1 Declare </summary>
                </details>  
                <details>
                        <summary>5.1.2 Rotation </summary>
                </details>                                      
                <details>
                        <summary>5.1.3 Search </summary>
                </details>                        
                <details>
                        <summary>5.1.4 Insertion </summary>
                </details>          
                <details>
                        <summary>5.1.5 Deletion </summary>
                </details>                  
        </details>  
        <details>
            <summary>6.Fenwick Tree</summary>
        </details>    
        <details>
            <summary>7.suffix tree</summary>
        </details>  
        <details>
            <summary>8.Prefix Tree</summary>
        </details>  
        <details>
            <summary>9.B-Tree</summary>
        </details>   
        <details>
            <summary>10. KD Tree</summary>
        </details>    
        <details>
            <summary>11.Treap</summary>
        </details>                           
    </details>
    <details>
        <summary>Graphs</summary>
        <details>
            <summary>1.Intro & Traversal</summary>
            <details>
                <summary>1.1 Rep(stl and class)</summary>
            </details>   
            <details>
                <summary>1.2 BFS</summary>
            </details>   
            <details>
                <summary>1.2 0-1 BFS</summary>
            </details>               
            <details>
                <summary>1.3 DFS</summary>
            </details>     
            <details>
                <summary>1.4 Find Mother Vertex</summary>
            </details>   
            <details>
                <summary>1.5 Watet-jug Prob(BFS)</summary>
            </details>   
            <details>
                <summary>1.6 Count #trees in forest</summary>
            </details>          
            <details>
                <summary>1.7 level of each node</summary>
            </details>   
            <details>
                <summary>1.8 Print All paths</summary>
            </details>   
            <details>
                <summary>1.9 Min #edges b/w 2 vertices</summary>
            </details>     
            <details>
                <summary>1.10 Count #nodes at dist k</summary>
            </details>   
            <details>
                <summary>1.11 BFS for disconnected</summary>
            </details>   
            <details>
                <summary>1.12 Min #moves by knight to reach target</summary>
            </details>  
            <details>
                <summary>1.12 Check if 2 nodes are in same path </summary>
            </details>                                                                         
        </details>   
        <details>
            <summary>2.Cycle</summary>
            <details>
                <summary>2.1 Detect Cycle in Directed Graph</summary>
            </details>             
            <details>
                <summary>2.2 Detect Cycle in Un-Directed Graph</summary>
            </details>             
            <details>
                <summary>2.3 Detect Cycle in Directed Grap Using Colors</summary>
            </details>       
           <details>
                <summary>2.4 Detect -ve cycle: Bellman Ford</summary>
            </details>             
            <details>
                <summary>2.5 Detect -ve cycle: Floyd Warshall</summary>
            </details>             
            <details>
                <summary>2.6 Union Find Algo</summary>
            </details>
            <details>
                <summary>2.6 Magical Indices in Array</summary>
            </details>                                                           
        </details>   
        <details>
            <summary>3.Topological Sort</summary>
            <details>
                <summary>3.1 About</summary>
            </details> 
            <details>
                <summary>3.2 All Top sort of directed connected graph</summary>
            </details>      
            <details>
                <summary>3.3 Kahn's algo</summary>
            </details>      
            <details>
                <summary>3.4 Longest Path(all 3)</summary>
            </details>                  
        </details>  
        <details>
            <summary>4.MSP</summary>
            <details>
                <summary>4.1 Prims algo(also STL, adjc list)</summary>
            </details> 
            <details>
                <summary>4.2 Kruskal's(also stl)</summary>
            </details>      
            <details>
                <summary>4.3 Boruvka</summary>
            </details>      
            <details>
                <summary>4.4 Total #spanning trees</summary>
            </details>  
        </details>   
        <details>
            <summary><5.Back-Track</summary>
            <details>
                <summary>5.1 if path of length >= k exists?</summary>
            </details> 
            <details>
                <summary>5.2 Tug of war</summary>
            </details>      
            <details>
                <summary>5.3 Knight tour</summary>
            </details>      
            <details>
                <summary>5.4 Rat in maze</summary>
            </details>      
            <details>
                <summary>5.5 n-Queen</summary>
            </details>      
            <details>
                <summary>5.6 m-coloring</summary>
            </details>      
            <details>
                <summary>5.7 HAMILTONIAN CYCLE</summary>
            </details>                 
        </details>   
        <details>
            <summary>6.Shortest Path</summary>
            <details>
                <summary>6.1 Dijkstra's(also stl & linked list)</summary>
            </details>      
            <details>
                <summary>6.2 printning all paths in Dijkstra</summary>
            </details>      
            <details>
                <summary>6.3 Bellman Ford</summary>
            </details>      
            <details>
                <summary>6.4 Floyd Warshall</summary>
            </details>      
            <details>
                <summary>6.5 Johnson</summary>
            </details>      
            <details>
                <summary>6.6 Dial's</summary>
            </details>      
            <details>
                <summary>6.7 shortest path in directed acyclic graph</summary>
            </details>      
            <details>
                <summary>6.8 Karp's</summary>
            </details>      
            <details>
                <summary>6.9 0-1 BFS</summary>
            </details>                       
        </details>  
        <details>
            <summary>7.Connectivity</summary>
            <details>
                <summary>7.1 connectivity in directed graph</summary>
            </details>      
            <details>
                <summary>7.2 is path exists?</summary>
            </details>      
            <details>
                <summary>7.3 Articulation Points</summary>
            </details>      
            <details>
                <summary>7.4 Biconnected components</summary>
            </details>      
            <details>
                <summary>7.5 Biconnected Graph</summary>
            </details>      
            <details>
                <summary>7.6 Bridges</summary>
            </details>      
            <details>
                <summary>7.7 Eulerian Paths</summary>
            </details>        
            <details>
                <summary>7.8 Fleury's</summary>
            </details>      
            <details>
                <summary>7.9 Strongly Connected</summary>
            </details>      
            <details>
                <summary>7.10 Taragn's</summary>
            </details>      
            <details>
                <summary>7.11 # non-reachable nvertices</summary>
            </details>      
            <details>
                <summary>7.12 check if graph is tree?</summary>
            </details>      
        </details>   
        <details>
            <summary>8.Max Flow</summary>
            <details>
                <summary>8.1 Ford-Fulkerson</summary>
            </details> 
            <details>
                <summary>8.2 #edge-disjoint paths b/w 2 vertices</summary>
            </details>      
            <details>
                <summary>8.3 Min s-t cut flow</summary>
            </details>      
            <details>
                <summary>8.4 Max bipartite matching</summary>
            </details>      
            <details>
                <summary>8.5 Karger's </summary>
            </details>      
            <details>
                <summary>8.6 Dinic's</summary>
            </details>                  
        </details>   
        <details>
            <summary>9.Hard</summary>
            <details>
                <summary>9.1 Graph Coloring</summary>
            </details> 
            <details>
                <summary>9.2 TSP(travelling slaseman)</summary>
            </details>                  
        </details>                                      
    </details> 
    <details>
        <summary>Linked List</summary>
        <details>
            <summary>1.Singly Linked List</summary>
            <details>
                <summary>1.1 Declaration</summary>
            </details> 
            <details>
                <summary>1.2 Traversal</summary>
            </details>      
            <details>
                <summary>1.3 Insertion</summary>
            </details>      
            <details>
                <summary>1.4 Deletion</summary>
            </details>      
            <details>
                <summary>1.5 Delete a ll</summary>
            </details>      
            <details>
                <summary>1.6 Search</summary>
            </details>      
            <details>
                <summary>1.7 Nth node from end</summary>
            </details>      
            <details>
                <summary>1.8 Print middle ele</summary>
            </details>      
            <details>
                <summary>1.9 detect loop</summary>
            </details>      
            <details>
                <summary>1.10 Find length of loop</summary>
            </details>    
            <details>
                <summary>1.11 isPalindrome?</summary>
            </details>   
            <details>
                <summary>1.12 Remove Duplicates from(sorted and unsorted)</summary>
            </details>    
            <details>
                <summary>1.13 Swap nodes</summary>
            </details>    
            <details>
                <summary>1.14 move last element to front</summary>
            </details>   
            <details>
                <summary>1.15 intersection of 2 ll</summary>
            </details>    
            <details>
                <summary>1.16.1 quicksort</summary>
            </details>    
            <details>
                <summary>1.16.2 insertion sort</summary>
            </details> 
            <details>
                <summary>1.16.3 merge sort</summary>
            </details>                            
            <details>
                <summary>1.17 Reverse a ll(2 pointer & recursion)</summary>
            </details>   
            <details>
                <summary>1.18 Merge 2 ll</summary>
            </details>   
            <details>
                <summary>1.19 Alternate odd and even nodes print</summary>
            </details>    
            <details>
                <summary>1.20 add 2 numbers rep by ll(both sets)</summary>
            </details>  
            <details>
                <summary>1.21 Rotate ll</summary>
            </details>   
            <details>
                <summary>1.22 flatten ll</summary>
            </details> 
            <details>
                <summary>1.23 Three sum</summary>
            </details>   
            <details>
                <summary>1.24 sort a ll of 0s,1s,2s</summary>
            </details> 
            <details>
                <summary>1.25 add 1 to a number</summary>
            </details>   
            <details>
                <summary>1.26 delete a node at given position</summary>
            </details>                                                                                                                                          
        </details> 
        <details>
            <summary>2. Circular Linked List</summary>
        </details>      
        <details>
            <summary>3.Doubly Linked List</summary>
        </details>             
    </details>
    <details>
        <summary>Hash</summary>
    </details>
    <details>
        <summary>Array</summary>
    <details>
        <summary>1. Rotations</summary>
        <details>
            <summary>1.1 Rotate by d(all 3)</summary>
        </details> 
        <details>
            <summary>1.2 reversal algo for arr rot</summary>
        </details>      
        <details>
            <summary>1.3 block swap algo</summary>
        </details>      
        <details>
            <summary>1.4 cyclically rotate arr</summary>
        </details>      
        <details>
            <summary>1.5 Search ele in sorted and rotated arr</summary>
        </details>      
        <details>
            <summary>1.6 given sorted & rotated arr, find 2 sum</summary>
        </details>      
        <details>
            <summary>1.7 find rotation count in rotated sorted arr</summary>
        </details>      
        <details>
            <summary>1.8 find min in rot-sorted arr</summary>
        </details>      
    </details> 
    <details>
        <summary>2. Arr-Rearr</summary>
        <details>
            <summary>2.1 rearr such that arr[i]=i</summary>
        </details> 
        <details>
            <summary>2.2 reverse arr</summary>
        </details>      
        <details>
            <summary>2.3 Rearrange array such that arr[i] >= arr[j] if i is even and arr[i]<=arr[j] if i is odd and j < i</summary>
        </details>      
        <details>
            <summary>2.4 Rearrange positive and negative numbers</summary>
        </details>      
        <details>
            <summary>2.5 Move all zeroes to end of array
(both sets)</summary>
        </details>      
        <details>
            <summary>2.6 Minimum swaps required to bring all elements less than or equal to k together</summary>
        </details>      
        <details>
            <summary>2.7 Rearrange array such that even positioned are greater than odd</summary>
        </details>      
        <details>
            <summary>2.8 Rearrange an array in order – smallest, largest, 2nd smallest, 2nd largest, ..
</summary>
        </details>      
        <details>
            <summary>2.9 Arrange given numbers to form the biggest number</summary>
        </details>      
        <details>
            <summary>2.10 
Rearrange an array in maximum minimum form(both sets)</summary>
        </details>   
        <details>
            <summary>2.11 Move all negative numbers to beginning and positive to end(both sets)</summary>
        </details> 
        <details>
            <summary>2.12 Rearrange array such that even index elements are smaller and odd index elements are greater
</summary>
        </details>      
        <details>
            <summary>2.13 Positive elements at even and negative at odd positions</summary>
        </details>      
        <details>
            <summary>2.14 Segregate 0s and 1s in an array</summary>
        </details>      
        <details>
            <summary>2.15 Longest Bitonic Subsequence
</summary>
        </details>      
        <details>
            <summary>2.16 Largest subarray with equal number of 0s and 1s</summary>
        </details>      
        <details>
            <summary>2.17 Maximum Product Sub-array
</summary>
        </details>      
        <details>
            <summary>2.18 Replace every element with the greatest element on right side
</summary>
        </details>  
        <details>
            <summary>2.19 Construction of Longest Increasing Subsequenc</summary>
        </details> 
        <details>
            <summary>2.19 
Sort elements by frequenc</summary>
        </details>      
        <details>
            <summary>2.20 Three way partitioning</summary>
        </details>      
        <details>
            <summary>2.21 Convert array into Zig-Zag fashion</summary>
        </details>      
        <details>
            <summary>2.22 Minimum number of swaps required for arranging pairs adjacent to each other</summary>
        </details>                                  
    </details>      
    <details>
        <summary>3. Order statistics </summary>
        <details>
            <summary>3.1 K’th Smallest/Largest Element in Unsorted Array(all 3 sets & stl & heap)</summary>
        </details> 
        <details>
            <summary>3.2 Kth smallest element in a row-wise and column-wise sorted 2D arra(all 2 sets)</summary>
        </details>      
        <details>
            <summary>3.3 Largest ele</summary>
        </details>      
        <details>
            <summary>3.4 Largest 3 ele's</summary>
        </details>      
        <details>
            <summary>3.5 Mean and median of an unsorted array</summary>
        </details>      
        <details>
            <summary>3.6 Median of Stream of Running Integers</summary>
        </details>      
        <details>
            <summary>3.7 Minimum product of k integers in an array of positive Integers</summary>
        </details>      
        <details>
            <summary>3.8 K-th Largest Sum Contiguous Subarray
</summary>
        </details>      
        <details>
            <summary>3.9 K maximum sum combinations from two arrays</summary>
        </details>      
        <details>
            <summary>3.10 K maximum sums of overlapping contiguous sub-arrays</summary>
        </details>          
        <details>
            <summary>3.11 K maximum sums of non-overlapping contiguous sub-arrays</summary>
        </details>   
        <details>
            <summary>3.12 Find k pairs with smallest sums in two arrays</summary>
        </details>          
        <details>
            <summary>3.13 Second largest element in an array</summary>
        </details>   
        <details>
            <summary>3.14 k-th smallest absolute difference of two elements in an array
</summary>
        </details>          
        <details>
            <summary>3.15 Find the smallest missing number</summary>
        </details>   
        <details>
            <summary>3.16 Maximum sum such that no two elements are adjacent</summary>
        </details>   
        <details>
            <summary>3.17 Next Greater Element</summary>
        </details>   
        <details>
            <summary>3.1</summary>
        </details>   
        <details>
            <summary>3.1</summary>
        </details>                                                                          
    </details>      
    <details>
        <summary>4. Range Queries</summary>
    </details>      
    <details>
        <summary>6. Optimization</summary>
    </details>                  
    <details>
        <summary>7. Matrix</summary>
    </details> 
    <details>
        <summary>8. Misc</summary>
    </details>          
    </details>
    <details>
        <summary>Strings</summary>
    </details>    
 
</details>
<details>
    <summary>Algo</summary>
    <details>
        <summary>1. Searching & Sorting</summary>
            <details>
                <summary>1.1 Search for key</summary>
                 <details>
                    <summary>1.1.1 Linear</summary>
                </details> 
                <details>
                    <summary>1.1.2 Binary</summary>
                </details>      
                <details>
                    <summary>1.1.3 Ternary</summary>
                </details>      
                <details>
                    <summary>1.1.4 Jump</summary>
                </details>      
                <details>
                    <summary>1.1.5 Interpolation</summary>
                </details>      
                <details>
                    <summary>1.1.6 Exponantial</summary>
                </details>                     
            </details>     
            <details>
                <summary>1.2 Search for pattern</summary>
                <details>
                    <summary>1.2.1 KMP</summary>
                </details> 
                <details>
                    <summary>1.2.2 Rabin_karp</summary>
                </details>  
            </details>  
            <details>
                <summary>1.2 Sort</summary>
                <details>
                    <summary>1.2.1 Selection(betterment and stability)</summary>
                </details> 
                <details>
                    <summary>1.2.2 Bubble(betterment) </summary>
                </details>      
                <details>
                    <summary>1.2.3 Insertion(recursion)</summary>
                </details>      
                <details>
                    <summary>1.2.4 Quick(recursion)</summary>
                </details>      
                <details>
                    <summary>1.2.5 Merge</summary>
                </details>      
                <details>
                    <summary>1.2.6 Heap</summary>
                </details>      
                <details>
                    <summary>1.2.7 Counting</summary>
                </details>      
                <details>
                    <summary>1.2.8 Bucket</summary>
                </details> 
                <details>
                    <summary>1.2.9 Merge</summary>
                </details>                                  
            </details>                           
    </details>  
    <details>
        <summary>2.Bakctrack</summary>
        <details>
            <summary>2.1 Knight's Tour</summary>
        </details> 
        <details>
            <summary>2.2 Rat in maze( || multiple jumps allowed)</summary>
        </details>      
        <details>
            <summary>2/3 N-Queen Prob( || in O(n)space)</summary>
        </details>      
        <details>
            <summary>2.4 Subset Sum</summary>
        </details>      
        <details>
            <summary>2.5 m-coloring prob</summary>
        </details>      
        <details>
            <summary>2.6 Hamiltonian Cycle</summary>
        </details>      
        <details>
            <summary>2.7 Sudoku</summary>
        </details>      
        <details>
            <summary>2.8 Cryptarithmetic Puzzle( ||stl)</summary>
        </details>      
        <details>
            <summary>2.9 Magnet Puzzle</summary>
        </details>      
        <details>
            <summary>2.10 Boggle ( || using Trie)</summary>
        </details>  
        <details>
            <summary>2.11 Remove invalid parentheses</summary>
        </details> 
        <details>
            <summary>2.12 Print all permutations of string</summary>
        </details>      
        <details>
            <summary>2.13 Tug Of War</summary>
        </details>      
        <details>
            <summary>2.14 8-queen problem</summary>
        </details>      
        <details>
            <summary>2.15 combinational Sum</summary>
        </details>      
        <details>
            <summary>2.16 Backtrack to find all subsets</summary>
        </details>  
        <details>
            <summary>2.17 Count all possible paths between 2 vertices</summary>
        </details> 
        <details>
            <summary>2.18 FInd all distinct subsets of given set</summary>
        </details>      
    </details> 
    <details>
        <summary>3.DP</summary>
        <details>
            <summary>3.1 Concepts</summary>
            <details>
                <summary>3.1.1 Tabulation vs Memoization</summary>
            </details>      
            <details>
                <summary>3.1.2 Optimal Substructure Property</summary>
            </details>  
            <details>
                <summary>3.1.3 Overlapping Subproblems Property</summary>
            </details>      
            <details>
                <summary>3.1.4 How to solve DP</summary>
            </details>              
        </details> 
        <details>
            <summary>3.2 Adv Concepts</summary>
            <details>
                <summary>3.2.1 Bitmasking -1D</summary>
            </details>      
            <details>
                <summary>3.2.2 Bitmasking -2D</summary>
            </details>      
            <details>
                <summary>3.2.3 Digit DP</summary>
            </details>                 
        </details> 
        <details>
            <summary>3.3 Basic Prob</summary>
            <details>
                <summary>3.3.1 Ugly Numbers</summary>
            </details> 
            <details>
                <summary>3.3.2 Fibonacci Numbers</summary>
            </details>  
            <details>
                <summary>3.3.3 nth Catalan number</summary>
            </details> 
            <details>
                <summary>3.3.3 Bell numbers(#ways to partiton a set)</summary>
            </details>   
            <details>
                <summary>3.3.4 Binomial Coeff</summary>
            </details> 
            <details>
                <summary>3.3.5 Tiling Prob</summary>
            </details>  
            <details>
                <summary>3.3.5 Gold Mine Prob</summary>
            </details> 
            <details>
                <summary>3.3.6 Coin Change Prob</summary>
            </details>                                        
            <details>
                <summary>3.3.7 Friends Pairing Prob</summary>
            </details> 
            <details>
                <summary>3.3.8 Subset Sum Prob( || in O(sum)space)</summary>
            </details>  
            <details>
                <summary>3.3.9 subsets with sum divisible by m</summary>
            </details> 
            <details>
                <summary>3.3.10 Largest divisible pairs subset</summary>
            </details>   
            <details>
                <summary>3.3.11 Perfect Sum prob(print all subsets with given sum)</summary>
            </details> 
            <details>
                <summary>3.3.12 nCr</summary>
            </details>  
            <details>
                <summary>3.3.13 Cutting a rod</summary>
            </details> 
            <details>
                <summary>3.3.14 Tiling with Dominos</summary>
            </details>        
            <details>
                <summary>3.3.15 Print Fibonacci series in reverse order</summary>
            </details>      
            <details>
                <summary>3.3.16 Longest common subsequence(|| space optimised sol)</summary>
            </details>        
            <details>
                <summary>3.3.17 Longest Repeated Subsequence</summary>
            </details>      
            <details>
                <summary>3.3.18 Find n-th element from Stern’s Diatomic Series</summary>
            </details>        
            <details>
                <summary>3.3.19 Find maximum possible stolen value from houses
</summary>
            </details>   
            <details>
                <summary>3.3.20 Find number of solutions of a linear equation of n variables</summary>
            </details>        
            <details>
                <summary>3.3.21 Count number of ways to reach a given score in a game</summary>
            </details>      
            <details>
                <summary>3.3.22 Count ways to reach the nth stair using step 1, 2 or 3</summary>
            </details>        
            <details>
                <summary>3.3.23 Counts paths from a point to reach Origin
</summary>
            </details>   
            <details>
                <summary>3.3.23 Count number of ways to cover a distance
</summary>
            </details>        
            <details>
                <summary>3.3.24 Count ways to divide circle using N non-intersecting chords
</summary>
            </details>   
            <details>
                <summary>3.3.25 Count the number of ways to tile the floor of size n x m using 1 x m size tiles</summary>
            </details>        
            <details>
                <summary>3.3.26 Count all possible paths from top left to bottom right of a mXn matrix</summary>
            </details>   
            <details>
                <summary>3.3.27 Unique paths in a Grid with Obstacles</summary>
            </details>        
            <details>
                <summary>3.3.28 Number of n-digits non-decreasing integers</summary>
            </details>      
            <details>
                <summary>3.3.29 Number of decimal numbers of length k, that are strict monotone</summary>
            </details>        
            <details>
                <summary>3.3.30 Different ways to sum n using numbers greater than or equal to m</summary>
            </details>  
            <details>
                <summary>3.3..........100</summary>
            </details>                  
        </details>      
        <details>
            <summary>3.4 Intermediate Prob</summary>
            <details>
                <summary>3.4.1 Lobb number</summary>
            </details>     
            <details>
                <summary>3.4.2 Eulerian number</summary>
            </details> 
            <details>
                <summary>3.4.3 Delannoy number</summary>
            </details>     
            <details>
                <summary>3.4.4 Rencontres number</summary>
            </details>  
            <details>
                <summary>3.4.5 Super ugly numbers(Number whose prime factors are in given set)</summary>
            </details>     
            <details>
                <summary>3.4.6 Jacobsthal and Jacobsthal-Lucas numbers</summary>
            </details> 
            <details>
                <summary>3.4.7 0-1 Knapsack Problem</summary>
            </details>     
            <details>
                <summary>3.4.8 Printing Items in 0/1 Knapsack</summary>
            </details>   
            <details>
                <summary>3.4.9 Unbounded Knapsack (Repetition of items allowed)
</summary>
            </details>     
            <details>
                <summary>3.5.6 A Space Optimized DP solution for 0-1 Knapsack Problem
</summary>            
            <details>
                <summary>3.4.10 Floyd Warshall Algorithm
</summary>
            </details> 
            <details>
                <summary>3.4.11 Bellman–Ford Algorithm
</summary>
            </details>     
            <details>
                <summary>3.4.12 Egg Dropping Puzzle
</summary>
            </details>  
            <details>
                <summary>3.4.13 Min Cost Path
</summary>
            </details>          
            <details>
                <summary>3.4.14 Min cost path
</summary>
            </details>                  
            <details>
                <summary>3.4.13 Temple Offerings</summary>
            </details>     
            <details>
                <summary>3.4.14 Dice Throw Problem</summary>
            </details> 
            <details>
                <summary>3.4.15 Word Break Prob</summary>
            </details>     
            <details>
                <summary>3.4.16 Word Break Problem</summary>
            </details>   
            <details>
                <summary>3.4.17 Vertex Cover Problem</summary>
            </details> 
            <details>
                <summary>3.4.18 Tile Stacking Problem</summary>
            </details>     
            <details>
                <summary>3.4.19 Box-Stacking Problem
</summary>
            </details>   
            <details>
                <summary>3.4.20 Highway Billboard Problem</summary>
            </details> 
            <details>
                <summary>3.4.21 Partition Problem
(all 3 sets)</summary>
            </details>     
            <details>
                <summary>3.4.22 High-effort vs. Low-effort Tasks Problem</summary>
            </details>   
            <details>
                <summary>3.4.23 Longest Bitonic Subsequence
</summary>
            </details> 
            <details>
                <summary>3.4.24 Longest Palindromic Subsequence
(|| with O(n))</summary>
            </details>     
            <details>
                <summary>3.4.25 Count All Palindromic Subsequence in a given String</summary>
            </details>  
            <details>
                <summary>3.4.26 Number of palindromic subsequences of length k
</summary>
            </details> 
            <details>
                <summary>3.4.27 Shortest Common Supersequence
</summary>
            </details>     
            <details>
                <summary>3.4.28 Longest Repeating Subsequence</summary>
            </details>   
            <details>
                <summary>3.4.29 Count Distinct Subsequences</summary>
            </details> 
            <details>
                <summary>3.4.30 Longest Zig-Zag Subsequence</summary>
            </details>     
            <details>
                <summary>3.4.31 Largest sum Zigzag sequence in a matrix
</summary>
            </details>   
            <details>
                <summary>3.4.32 Weighted job scheduling(all 3 sets)</summary>
            </details> 
            <details>
                <summary>3.4.33 Number of paths with exactly k coins
</summary>
            </details>     
            <details>
                <summary>3.4.34 Count Possible Decodings of a given Digit Sequence</summary>
            </details>   
            <details>
                <summary>3.4.35 Count number of ways to partition a set into k subsets</summary>
            </details> 
            <details>
                <summary>3.4.36 Count of n digit numbers whose sum of digits equals to given sum
</summary>
            </details>     
            <details>
                <summary>3.4.37 
Count ways to assign unique cap to every person</summary>
            </details>     
            <details>
                <summary>3.4.38 Length of the longest substring without repeating characters</summary>
            </details>     
            <details>
                <summary>3.4.  Travelling Salesman Problem | Set 1 (Naive and Dynamic Programming)</summary>
            </details>     
            <details>
                <summary>3.4..........100</summary>
            </details>                                                                                                                 
        </details>      
        <details>
            <summary>3.5 Hard Prob</summary>
            <details>
                <summary>3.5.1 Palindrome Partitioning </summary>
            </details>  
            <details>
                <summary>3.5.2 Word-wrap Problem</summary>
            </details>  
            <details>
                <summary>3.5.3 Painters problem</summary>
            </details>  
            <details>
                <summary>3.5.4 Boolean Parenthesization Problem
</summary>
            </details>  
            <details>
                <summary>3.5.5 Program for Bridge and Torch problem</summary>
            </details>  
            <details>
                <summary>3.5.6 A Space Optimized DP solution for 0-1 Knapsack Problem
</summary>
            </details>   
            <details>
                <summary>3.5.7 Matrix Chain Multiplication</summary>                                                          
            </details>
            <details>
                <summary>3.5.8 Printing brackets in Matrix Chain Multiplication Problem</summary>                                                          
            </details>
            <details>
                <summary>3.5.9 Number of palindromic paths in a matrix
</summary>                                                          
            </details>
            <details>
                <summary>3.5.10 Largest rectangular sub-matrix whose sum is 0
</summary>                                                          
            </details>
            <details>
                <summary>3.5.11 Largest rectangular sub-matrix having sum divisible by k
</summary>                                                          
            </details>
            <details>
                <summary>3.5.12 Largest area rectangular sub-matrix with equal number of 1’s and 0’s
            </summary> 
             <details>
            <details>
                <summary>3.5.13 Maximum sum bitonic subarray</summary>
            </details> 
            <details>
                <summary>3.5.14 Maximum sum rectangle in a 2D matrix</summary>
            </details>      
            <details>
                <summary>3.5.15 Maximum Subarray Sum Excluding Certain Elements</summary>
            </details>      
            <details>
                <summary>3.5.16 Maximum weight transformation of a given string
</summary>
            </details>                   
            </details>                                    
                <summary>3.4..........100</summary>
            </details>                             
        </details>      
    </details>      
    <details>
        <summary>4.Greedy</summary>
        <details>
            <summary>4.1 Standard algos</summary>
            <details>
                <summary>4.1.1 Activity Selection Prob</summary>
            </details> 
            <details>
                <summary>4.1.2 Egyptian Fraction</summary>
            </details>      
            <details>
                <summary>4.1.3 Job Sequencing Problem
(~||disjoint sets || loss minimisation-1||loss minimisation -2)</summary>
            </details>      
            <details>
                <summary>4.1.4 Huffman Coding(~||for sorted input)</summary>
            </details>  
            <details>
                <summary>4.1.5 Huffman Decoding</summary>
            </details> 
            <details>
                <summary>4.1.6 Water Connection Prob</summary>
            </details>      
            <details>
                <summary>4.1.7 Policeman catch thieves</summary>
            </details>      
            <details>
                <summary>4.1.8 Minimum Swaps for Bracket Balancing</summary>
            </details>      
           <details>
                <summary>4.1.9 Fitting Shelves Problem
</summary>
            </details>      
           <details>
                <summary>4.1.10 Assign Mice to Holes
</summary>
            </details>                                                   
        </details> 
        <details>
            <summary>4.2 Greedy in Graph</summary>
            <details>
                <summary>4.2.1 Kruskal's MSP</summary>
            </details> 
            <details>
                <summary>4.2.2 Prim's MSP</summary>
            </details>      
            <details>
                <summary>4.2.3 Boruvka's MSP</summary>
            </details>      
            <details>
                <summary>4.2.3 Dijkstra's shortest path</summary>
            </details>      
            <details>
                <summary>4.2.4 Dial's</summary>
            </details>      
            <details>
                <summary>4.2.5 Min cost</summary>
            </details>      
            <details>
                <summary>4.2.6 Max flow</summary>
            </details>      
            <details>
                <summary>4.2.7 #single cycle components in undirected graph</summary>
            </details>      
        </details>      
        <details>
            <summary>4.3 Greedy in arrays</summary>
            <details>
                <summary>4.3.1 Min product subset</summary>
            </details> 
            <details>
                <summary>4.3.2 Max product subset</summary>
            </details>      
            <details>
                <summary>4.3.3 Maximize array sum after k-negations(both sets)</summary>
            </details>      
            <details>
                <summary>4.3.4 Maximize the sum of arr[i]*i
</summary>
            </details>      
            <details>
                <summary>4.3.5 Maximum sum of increasing order elements from n arrays
</summary>
            </details>      
            <details>
                <summary>4.3.6 Maximum sum of absolute difference of an array</summary>
            </details>      
            <details>
                <summary>4.3.7 Maximize sum of consecutive differences in a circular array</summary>
            </details>      
            <details>
                <summary>4.3.8 Maximum height pyramid from the given array of objects
</summary>
            </details>      
            <details>
                <summary>4.3.9 Partition into two subarrays of lengths k and (N – k) such that the difference of sums is maximum
</summary>
            </details>      
            <details>
                <summary>4.3.10 Minimum sum of product of two arrays</summary>
            </details>     
            <details>
                <summary>4.3.11 Minimum sum by choosing minimum of pairs from array
</summary>
            </details> 
            <details>
                <summary>4.3.12 Minimum sum of absolute difference of pairs of two arrays
</summary>
            </details>      
            <details>
                <summary>4.3.13 Minimum operations to make GCD of array a multiple of k
</summary>
            </details>      
            <details>
                <summary>4.3.14 Minimum sum of absolute difference of pairs of two arrays
</summary>
            </details>      
            <details>
                <summary>4.3.15 Minimum sum of two numbers formed from digits of an array
</summary>
            </details>      
            <details>
                <summary>4.3.16 Minimum increment/decrement to make array non-Increasing</summary>
            </details>      
            <details>
                <summary>4.3.17 Minimize sum of product of two arrays with permutation allowed</summary>
            </details>      
            <details>
                <summary>4.3.18 Sorting array with reverse around middle
</summary>
            </details>      
            <details>
                <summary>4.3.19 Sum of Areas of Rectangles possible for an array
</summary>
            </details>      
            <details>
                <summary>4.3.20 Array element moved by k using single moves</summary>
            </details>           
            <details>
                <summary>4.3.21 Find if k bookings possible with given arrival and departure times
</summary>
            </details>           
            <details>
                <summary>4.3.22 Lexicographically smallest array after at-most K consecutive swaps
</summary>
            </details> 
            <details>
                <summary>4.3.23 Largest lexicographic array with at-most K consecutive swaps
</summary>
            </details>                                                            
        </details>      
        <details>
            <summary>4.4 Greedy in OS</summary>
            <details>
                <summary>4.4.1 First Fit algorithm in Memory Management</summary>
            </details> 
            <details>
                <summary>4.4.2 Best Fit algorithm in Memory Management
</summary>
            </details>      
            <details>
                <summary>4.4.3 Worst Fit algorithm in Memory Management</summary>
            </details>      
            <details>
                <summary>4.4.4 Operating System | Program for Next Fit algorithm in Memory Management
</summary>
            </details>      
            <details>
                <summary>4.4.5 Shortest Job First Scheduling
</summary>
            </details>      
            <details>
                <summary>4.4.6 Program for Shortest Job First (SJF) scheduling | Set 2 (Preemptive)
</summary>
            </details>      
            <details>
                <summary>4.4.7 Schedule jobs so that each server gets equal load
</summary>
            </details>      
            <details>
                <summary>4.4.8 Job Scheduling with two jobs allowed at a time</summary>
            </details>      
            <details>
                <summary>4.4.9 Scheduling priority tasks in limited time and minimizing loss
</summary>
            </details>      
            <details>
                <summary>4.4.10 Page Replacement (~|| LRU || FIFO)</summary>
            </details>                      
        </details>      
        <details>
            <summary>4.5 Apporx Greedy for NP-complete probs</summary>
        </details>      
        <details>
            <summary>4.6 Misc</summary>
            <details>
                <summary>4.6.1 Split n into maximum composite numbers</summary>
            </details> 
            <details>
                <summary>4.6.2 Maximum trains for which stoppage can be provided</summary>
            </details>      
            <details>
                <summary>4.6.3 Buy Maximum Stocks if i stocks can be bought on i-th day
</summary>
            </details>      
            <details>
                <summary>4.6.4 Find the minimum and maximum amount to buy all N candies
</summary>
            </details>      
            <details>
                <summary>4.6.5 Maximum sum possible equal to sum of three stacks
</summary>
            </details>      
            <details>
                <summary>4.6.6 Maximum elements that can be made equal with k updates
</summary>
            </details>      
            <details>
                <summary>4.6.7 Divide cuboid into cubes such that sum of volumes is maximum
</summary>
            </details>      
            <details>
                <summary>4.6.8 Maximum number of customers that can be satisfied with given quantity
</summary>
            </details>      
            <details>
                <summary>4.6.9 Minimum Fibonacci terms with sum equal to K
</summary>
            </details>      
            <details>
                <summary>4.6.10 Divide 1 to n into two groups with minimum sum difference
</summary>
            </details>  
            <details>
                <summary>4.6.11 Minimize cash flow among friends
</summary>
            </details> 
            <details>
                <summary>4.6.12 Minimum rotations to unlock a circular lock
</summary>
            </details>      
            <details>
                <summary>4.6.13 Paper cut into minimum number of squares
</summary>
            </details>      
            <details>
                <summary>4.6.14 Minimum difference between groups of size two
</summary>
            </details>      
            <details>
                <summary>4.6.15 Minimum rooms for m events of n batches with given schedule
</summary>
            </details>      
            <details>
                <summary>4.6.16 Connect n ropes with minimum cost
</summary>
            </details>      
            <details>
                <summary>4.6.17 Minimum Cost to cut a board into squares
</summary>
            </details>      
            <details>
                <summary>4.6.18 Minimum cost to process m tasks where switching costs
</summary>
            </details>      
            <details>
                <summary>4.6.19 Minimum cost to make array size 1 by removing larger of pairs
</summary>
            </details>      
            <details>
                <summary>4.6.20 Minimum cost for acquiring all coins with k extra coins allowed with every coin</summary>
            </details>   
            <details>
                <summary>4.6.21 Minimum time to finish all jobs with given constraints </summary>
            </details> 
            <details>
                <summary>4.6.22 Minimum number of Platforms required for a railway/bus station
</summary>
            </details>      
            <details>
                <summary>4.6.23 Minimize the maximum difference between the heights of towers
</summary>
            </details>      
            <details>
                <summary>4.6.24 Minimum increment by k operations to make all elements equal</summary>
            </details>      
            <details>
                <summary>4.6.25 Minimum edges to reverse to make path from a source to a destination</summary>
            </details>      
            <details>
                <summary>4.6.26 Find minimum number of currency notes and values that sum to given amount</summary>
            </details>      
            <details>
                <summary>4.6.27 Minimum initial vertices to traverse whole matrix with given conditions</summary>
            </details>      
            <details>
                <summary>4.6.28 Find the Largest Cube formed by Deleting minimum Digits from a number</summary>
            </details>      
            <details>
                <summary>4.6.29 Check if it is possible to survive on Island
</summary>
            </details>      
            <details>
                <summary>4.6.30 Largest palindromic number by permuting digits
</summary>
            </details>   
            <details>
                <summary>4.6.31 Smallest number with sum of digits as N and divisible by 10^N</summary>
            </details> 
            <details>
                <summary>4.6.32 Find Smallest number with given number of digits and digits sum
</summary>
            </details>      
            <details>
                <summary>4.6.33 Rearrange characters in a string such that no two adjacent are same
</summary>
            </details>      
            <details>
                <summary>4.6.34 Rearrange a string so that all same characters become d distance away
</summary>
            </details>      
            <details>
                <summary>4.6.35 Print a closest string that does not contain adjacent duplicates
</summary>
            </details>      
            <details>
                <summary>4.6.36 Smallest subset with sum greater than all other elements</summary>
            </details>      
            <details>
                <summary>4.6.37 Lexicographically largest subsequence such that every character occurs at least k times</summary>
            </details>      
        </details>      
        <details>
            <summary>4.7 Greedy for special cases of DP probs</summary>
            <details>
                <summary>4.7.1 Set Cover Prob</summary>
            </details> 
            <details>
                <summary>4.7.2 Bin Packing Prob</summary>
            </details>      
            <details>
                <summary>4.7.3 Graph Coloring</summary>
            </details>      
            <details>
                <summary>4.7.4 K-centre Prob</summary>
            </details>      
            <details>
                <summary>4.7.5 Shortest superstring</summary>
            </details>      
            <details>
                <summary>4.7.6 TSP(naive-dry || MST)</summary>
            </details>               
        </details>        
    </details>      
    <details>
        <summary>5.Bitwise</summary>
        <details>
            <summary>5.1 Basic</summary>
            <details>
                <summary>5.1.1 Find the element that appears once</summary>
            </details> 
            <details>
                <summary>5.1.2 Detect if two integers have opposite signs
</summary>
            </details>      
            <details>
                <summary>5.1.3 Add 1 to a given number</summary>
            </details>      
            <details>
                <summary>5.1.4 Multiply a given Integer with 3.5
</summary>
            </details>      
            <details>
                <summary>5.1.5 Turn off the rightmost set bit</summary>
            </details>      
            <details>
                <summary>5.1.6 Find whether a given number is a power of 4 or not
</summary>
            </details>      
            <details>
                <summary>5.1.7 Compute modulus division by a power-of-2-number</summary>
            </details>      
            <details>
                <summary>5.1.8 Rotate bits of a number
</summary>
            </details>      
            <details>
                <summary>5.1.9 Find the Number Occurring Odd Number of Times
</summary>
            </details>      
            <details>
                <summary>5.1.10 Check for Integer Overflow
</summary>
            </details>   
            <details>
                <summary>5.1.11 Count set bits in an integer
</summary>
            </details> 
            <details>
                <summary>5.1.12 Count number of bits to be flipped to convert A to B
</summary>
            </details>      
            <details>
                <summary>5.1.13 Efficient way to multiply with 7</summary>
            </details>      
            <details>
                <summary>5.1.14 Program to find whether a no is power of two</summary>
            </details>      
            <details>
                <summary>5.1.15 Position of rightmost set bit
</summary>
            </details>      
            <details>
                <summary>5.1.16 Binary representation of a given number</summary>
            </details>      
            <details>
                <summary>5.1.17 Find position of the only set bit
</summary>
            </details>      
            <details>
                <summary>5.1.18 How to swap two numbers without using a temporary variable?
</summary>
            </details>      
            <details>
                <summary>5.1.19 Swap two nibbles in a byte</summary>
            </details>      
            <details>
                <summary>5.1.20 How to turn off a particular bit in a number?
</summary>
            </details>   
            <details>
                <summary>5.1.21 Russian Peasant (Multiply two numbers using bitwise operators)
</summary>
            </details> 
            <details>
                <summary>5.1.22 Add two bit strings
</summary>
            </details>      
            <details>
                <summary>5.1.23 Write your own strcmp that ignores cases</summary>
            </details>      
            <details>
                <summary>5.1.24 Check if two numbers are equal without using arithmetic and comparison operators
</summary>
            </details>      
            <details>
                <summary>5.1.25 Find XOR of two number without using XOR operator</summary>
            </details>      
            <details>
                <summary>5.1.26 Calculate XOR from 1 to n</summary>
            </details>      
            <details>
                <summary>5.1.27 Count minimum bits to flip such that XOR of A and B equal to C</summary>
            </details>      
            <details>
                <summary>5.1.28 Efficient method for 2’s complement of a binary string</summary>
            </details>      
            <details>
                <summary>5.1.29 Toggling k-th bit of a number</summary>
            </details>      
            <details>
                <summary>5.1.30 Convert decimal fraction to binary number
</summary>
            </details>   
            <details>
                <summary>5.1.31 Set the rightmost unset bit
</summary>
            </details> 
            <details>
                <summary>5.1.32 Convert a binary number to octal</summary>
            </details>      
            <details>
                <summary>5.1.33 Toggle bits in the given range</summary>
            </details>      
            <details>
                <summary>5.1.34 Toggle the last m bits
</summary>
            </details>      
            <details>
                <summary>5.1.........100</summary>
            </details>      
        </details> 
        <details>
            <summary>5.2 Intermediate</summary>
            <details>
                <summary>5.2.1 Swap bits in a given number</summary>
            </details> 
            <details>
                <summary>5.2.2 Little and Big Endian Mystery
</summary>
            </details>      
            <details>
                <summary>5.2.3 Smallest of three integers without comparison operators</summary>
            </details>      
            <details>
                <summary>5.2.4 A Boolean Array Puzzle
</summary>
            </details>      
            <details>
                <summary>5.2.5 Compute the integer absolute value (abs) without branching
</summary>
            </details>      
            <details>
                <summary>5.2.6 Compute the minimum or maximum of two integers without branching</summary>
            </details>      
            <details>
                <summary>5.2.7 Find the two non-repeating elements in an array of repeating elements</summary>
            </details>      
            <details>
                <summary>5.2.8 Write an Efficient C Program to Reverse Bits of a Number
</summary>
            </details>      
            <details>
                <summary>5.2.9 Smallest power of 2 greater than or equal to n
</summary>
            </details>    
            <details>
                <summary>5.2.10 find the parity of an unsigned integer</summary>
            </details> 
            <details>
                <summary>5.2.11 Swap all odd and even bits
</summary>
            </details>      
            <details>
                <summary>5.2.12 Check if binary representation of a number is palindrome
</summary>
            </details>      
            <details>
                <summary>5.2.13 Generate n-bit Gray Codes
</summary>
            </details>      
            <details>
                <summary>5.2.14 Check if a given number is sparse or not
</summary>
            </details>      
            <details>
                <summary>5.2.15 Euclid’s Algorithm when % and / operations are costly
</summary>
            </details>      
            <details>
                <summary>5.2.16 Find nth Magic Number
</summary>
            </details>      
            <details>
                <summary>5.2.17 How to swap two bits in a given integer?
</summary>
            </details>      
            <details>
                <summary>5.2.18 Calculate square of a number without using *, / and pow()</summary>
            </details>      
            <details>
                <summary>5.2.19 enerate 0 and 1 with 25% and 75% probability</summary>
            </details>            
            <details>
                <summary>5.2.20 Find even occurring elements in an array of limited range</summary>
            </details> 
            <details>
                <summary>5.2.21 Cyclic Redundancy Check and Modulo-2 Division</summary>
            </details>      
            <details>
                <summary>5.2.22 Copy set bits in a range</summary>
            </details>      
            <details>
                <summary>5.2.23 Check if a number is Bleak
</summary>
            </details>      
            <details>
                <summary>5.2.24 Count strings with consecutive 1’s
</summary>
            </details>    
            <details>
                <summary>5.2.25 Gray to Binary and Binary to Gray conversion
</summary>
            </details>                                      
            <details>
                <summary>5.2......100</summary>
            </details>                  
        </details>      
        <details>
            <summary>5.3 Hard</summary>
            <details>
                <summary>5.3.1 Count total set bits in all numbers from 1 to n
</summary>
            </details> 
            <details>
                <summary>5.3.2 Program to count number of set bits in an (big) array
</summary>
            </details>      
            <details>
                <summary>5.3.3 Next higher number with same number of set bits</summary>
            </details>      
            <details>
                <summary>5.3.4 Karatsuba algorithm for fast multiplication</summary>
            </details>      
            <details>
                <summary>5.3.5 Find the maximum subarray XOR in a given array
</summary>
            </details>      
            <details>
                <summary>5.3.6 Inserting m into n such that m starts at bit j and ends at bit i</summary>
            </details>      
            <details>
                <summary>5.3.7 Find Duplicates of array using bit array
</summary>
            </details>      
            <details>
                <summary>5.3.8 Find longest sequence of 1’s in binary representation with one flip</summary>
            </details>      
            <details>
                <summary>5.3.9 Closest (or Next) smaller and greater numbers with same number of set bits
</summary>
            </details>      
            <details>
                <summary>5.3.10 Bitmasking and Dynamic Programming | Set-2 (TSP)</summary>
            </details>   
            <details>
                <summary>5.3.11 Compute the parity of a number using XOR and table look-up
</summary>
            </details> 
            <details>
                <summary>5.3.12 XOR Encryption by Shifting Plaintext</summary>
            </details>      
            <details>
                <summary>5.3.13 Count pairs in an array which have at least one digit common
</summary>
            </details>      
            <details>
                <summary>5.3.14 Levelwise Alternating OR and XOR operations in Segment Tree</summary>
            </details>      
            <details>
                <summary>5.3.15 Booth’s Multiplication Algorithm</summary>
            </details>      
            <details>
                <summary>5.3.16 Leftover element after performing alternate Bitwise OR and Bitwise XOR operations on adjacent pairs</summary>
            </details>      
            <details>
                <summary>5.3.17 Number of pairs with Pandigital Concatenation
</summary>
            </details>      
            <details>
                <summary>5.3.18 Find the n-th number whose binary representation is a palindrome</summary>
            </details>      
            <details>
                <summary>5.3.........100</summary>
            </details>                        
        </details>       
        <details>
            <summary>5.4 Misc</summary>
        </details>            
    </details>      
    <details>
        <summary>5.Geometry/Maths</summary>
    </details>      
    <details>
        <summary>6.Div & Conq</summary>
    </details>    
</details>     
<!-- demo -->
<!-- 
<details>
    <summary></summary>
</details> 
<details>
    <summary></summary>
</details>      
<details>
    <summary></summary>
</details>      
<details>
    <summary></summary>
</details>      
<details>
    <summary></summary>
</details>      
<details>
    <summary></summary>
</details>      
<details>
    <summary></summary>
</details>      
<details>
    <summary></summary>
</details>      
<details>
    <summary></summary>
</details>      
<details>
    <summary></summary>
</details>          
  -->